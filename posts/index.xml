<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Melo&#39;s Blog</title>
		<link>https://blog.xn--4gq986klnp.cn/posts/</link>
		<description>Recent content in Posts on Melo&#39;s Blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-CN</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 07 Jun 2022 15:53:57 +0800</lastBuildDate>
		<atom:link href="https://blog.xn--4gq986klnp.cn/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>How to Write the Project Planning Scheme</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/how-to-write-the-project-planning-scheme/</link>
			<pubDate>Tue, 07 Jun 2022 15:53:57 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/how-to-write-the-project-planning-scheme/</guid>
			<description>写项目规划方案主要需要注意以下几个方面：一、背景目标；二、技术方案；三、实施策略；四、计划安排；五、风险及应对；六、结语。关于项目规划方案的</description>
			<content type="html"><![CDATA[<blockquote>
<p>写项目规划方案主要需要注意以下几个方面：一、背景目标；二、技术方案；三、实施策略；四、计划安排；五、风险及应对；六、结语。关于项目规划方案的具体内容我们将在文章中展开。</p>
</blockquote>
<h4 id="一背景目标">一、背景目标</h4>
<p>这部分主要对两个W——WHY &amp; WHERE 进行说明，描述该项目应对的需求或问题，以及预期达成的目标。需要强调的是务必把预期的输出成果和目标效果说清楚，其中有两个关键词：用户和场景。</p>
<p>用户：好的产品是找准用户的，所以满足的是谁的需求、或解决的是谁的问题，这点必须很明确。用户如果不明确的话，项目做完之后就不知道该向谁去推广了。</p>
<p>场景：具体的需求或问题一定离不开场景的，场景说明的就是项目的输出成果会在什么时候按照什么流被使用。这一点如果不明确的话，用户拿到产品可能也不知道这些新功能或新特性有什么用。</p>
<h4 id="二技术方案方案设计工作方案">二、技术方案（方案设计/工作方案）</h4>
<p>这部分主要对WHAT &amp; HOW 进行说明，即说明为达成目标，具体进行怎样的产品设计以及采用怎样的技术方案，包括产品的UI设计、交互设计、架构设计、技术选型、流程设计等等，总之就是把具体怎么做说清楚。这个关键的关键词是：逻辑性。</p>
<h4 id="三实施策略">三、实施策略</h4>
<p>这部分是对HOW的补充，也就是项目在具体操作过程中需要考虑的点。</p>
<h4 id="四计划安排">四、计划安排</h4>
<p>这部分主要对另外两个W——WHEN &amp; WHO 进行说明，明确组织保障和时间计划。</p>
<p>划定项目团队层次结构图：明确参与项目的团队及各方职责，如果是一个团队那也会分组，如果连分组也不用，那么这部分可以需要。</p>
<p>任务分解与分配：基于技术方案，在实施策略的指引进行任务分解和优先级编排，明确任务的输出成果、依赖关系以及计划完成时间，形成一个完整的任务清单；之后根据职责划分，为每一项任务排定负责人。</p>
<p>资源申请：根据各项任务所需，梳理汇总所需的人力、服务器、费用等相关资源，用于评估项目成本和项目启动准备。</p>
<p>其他涉及到计划安排的事宜也都可以在这个环节进行说明。</p>
<h4 id="五风险及应对">五、风险及应对</h4>
<p>这部分是进一步对HOW的补充说明，也就是对实施过程中可能会出现的风险进行预判，并提前设计好应对措施和流程。</p>
<h4 id="六结语">六、结语</h4>
<p>扩展资料：
项目规划规划方案过程：</p>
<ol>
<li>
<p>收集资料，明确和收集制定项目计划的资料，数据，依据和前提。</p>
</li>
<li>
<p>学习方法，工具和技术。</p>
</li>
<li>
<p>写出项目计划书和有关辅助文件。</p>
</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>车云一体及SOA相关知识学习</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/soa-study/</link>
			<pubDate>Fri, 06 May 2022 16:45:57 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/soa-study/</guid>
			<description>SOA架构 SOA概述 面向服务的架构。服务和功能联系密切，而汽车SOA就是将汽车各子系统中最小功能的逻辑单位抽离出来，封装成服务。 理解 将SOA</description>
			<content type="html"><![CDATA[<h3 id="soa架构">SOA架构</h3>
<p><img src="/image/soa-study/soa-study.jpeg" alt="alt soa-study" title="长城汽车SOA架构设计理念"></p>
<h4 id="soa概述">SOA概述</h4>
<p>面向服务的架构。服务和功能联系密切，<strong>而汽车SOA就是将汽车各子系统中最小功能的逻辑单位抽离出来，封装成服务。</strong></p>
<h4 id="理解">理解</h4>
<blockquote>
<p>将SOA架构搭建的平台同苹果App Store类比。SOA软件平台之于汽车，就好比App Store之于iPhone，它将汽车的硬件能力开放出来，供软件开发者调用。</p>
</blockquote>
<p>服务是SOA的主体，服务之间的关系构成了SOA软件架构。将服务比作砖石，那么SOA软件架构必然是参天大厦，而大厦不同的楼层，代表着服务之间的相互依赖、连接关系。即，SOA软件架构中，隐含着分层思想，服务是可分层的服务。上层服务使用下层服务，下层服务给上层提供能力支撑。通过将不同上层服务的需求抽离聚合，形成一个个下层服务，逐步迭代，最终形成SOA软件服务的分层架构。在新四化浪（电动化、网联化、智能化、共享化）潮下，车辆联网的普及率非常高，所以我们设计的SOA软件架构包括车端SOA软件架构+云端软件架构。</p>
<p>若换个角度，从用户体验“功能”出发，将这些最小单元的功能模块形容成「乐高玩具的每个零件」，借此可以对使用SOA软件平台有更直观地了解。如果我们将这些「零件」提供给用户和开发者，其实可以有多种组合形成丰富的功能。用户和开发者简单地通过几个模块拖拽和参数选择，定制专属功能。比如很多人开车时要抽烟，可能喜好就是打开天窗换气，但是你则希望将车窗打开。此时显然能有两个「零件」能够搭在一起，从而实现DIY和满足个性化需求。还比如，将主驾座椅按摩作为一个「零件」，单独调用；也可以与打开天窗配合，来实现自定义服务；还可以与疲劳监测功能配合，做出疲劳预警。</p>
<p>可以发现，同一「零件」在不同例子中被用户调用，模块化后它们变得“可复用”。「零件」提前准备，可随时给用户的自定义服务增加功能，从而“易扩展”，其本质是一种<strong>面向用户的自定义编程模式</strong>。</p>
<p>SOA升级的是软件架构，而呈现在用户面前的始终只有软件。用户将自己编程后的场景上传到SOA软件平台，车机端屏幕同步显示，可以便捷使用自己制作的APP。通过这一模式，在保证安全的前提下，用户可以开放地自己OTA，分享给其他人OTA，让汽车OTA频率提高。这会实现“常用常新”，也是车企保持产品竞争力的方式。</p>
<h4 id="soa软件架构层级">SOA软件架构层级</h4>
<p>将SOA服务分为基础服务、扩展服务、应用服务。这三种服务类型，分别对应着不同能力属性，每一类服务都有着明确的服务单一性，即，每一个服务单元都只提供一种服务或者说只有一种功能。从这里也可以看出，服务的形成是因为功能，而不同使用者对同一个功能的需求，促使了服务下沉聚合。多个上层服务使用同一个下层服务，那么便出现了服务标准化的需求，简单说就是服务接口的标准化。</p>
<p>SOA软件架构还有另外一些特性：高内聚、低耦合、服务平台无关化、服务动态部署/动态发现。所以，将基于SOA架构的操作系统分成如下层级，已实现完整意义上的SOA软件架构。</p>
<ol>
<li>OS AL层：屏蔽操作系统对SOA架构的影响</li>
<li>SOA Framework层：提供基于SOA架构的服务设计所需的所有基础组件</li>
<li>SOA Platform层：提供通用化的SOA服务，提高功能的复用率，共包含2个子块：a）基础服务层：可独立运行，无外部依赖的服务；b）扩展服务层：使用基础服务，进行横向组合扩展，实现复杂功能逻辑的服务</li>
<li>外部服务层：根据项目需求，使用其他域控制器或云端提供的服务接口，实现“云管端一体化SOA软件平台”</li>
<li>应用服务层：基于SOA Framework和SOA Platform提供的能力支撑，根据需求定制的逻辑业务功能。</li>
<li>应用层适配接口层：将SOA服务与应用层隔离开，转化SOA服务接口为不同系统的native开发语言，加速应用层开发效率，使应用层与SOA服务层隔离。</li>
<li>Cloud Service层：基于SOA软件架构，通过车云一体化软件组件实现车端—云端服务对等且位置无关化。</li>
</ol>
<p>并且，在层级设计过程中，域内/域间不同层级间的接口设计遵循标准C/C++接口规范和标准POSIX接口规范，与云端采用服务代理的方式，内部封装标准RESTful规范接口。这种规则赋予了SOA服务的平台无关化属性，从而，整个SOA软件架构也就实现了平台无关化</p>
<h4 id="soa软件架构的设计方式">SOA软件架构的设计方式</h4>
<p>SOA软件架构在巨大的推动力下在向前奔跑，设计优越的SOA软件架构，必然要满足以下特征：</p>
<ol>
<li>屏蔽异构性：SOA服务间采用标准中立的接口和契约，屏蔽不同硬件、系统、开发语言间的差异。</li>
<li>服务可复用：可通过组件之间的组装、编排和重组，来实现服务的复用。</li>
<li>数据共享：SOA服务层级中，所有服务均与总线连接，意味着每一个服务都可以获取到连接到总线上的服务所提供的数据，打破了传统功能的信息孤岛。</li>
<li>灵活调整：基于总线的SOA服务，无需关心服务的位置，服务间以总线作为连接的桥梁，每个服务可根据需求灵活迁移、升级等。</li>
<li>降低用户成本：用户无需关心各服务间的language binding，仅需通过现有标准化接口调用，实现服务功能即可。</li>
<li>服务运行状态管控：SOA中的服务注册发现能力，可帮助用户识别异常服务，保证系统正常运行。</li>
<li>云管端一体化服务平台：建立车端服务与云端服务的对等关系，云端服务与车端服务采用标准化的统一接口进行交互，完成服务功能。</li>
</ol>
<p>以上特征中，提到3个很重要的点：</p>
<ol>
<li>一个是服务治理能力</li>
<li>另一个是总线，在这里特指的是ESB总线（Enterprise Service Bus）</li>
<li>最后一个是上面提到的车云一体化软件组件</li>
</ol>
<p>其中，服务治理能力包含如下部分：</p>
<ol>
<li>
<p>服务动态发现：服务支持动态插入、删除、更新，由服务提供方管理服务的所有依赖关系、资源需求等，并控制服务offer/stop的时序。</p>
</li>
<li>
<p>服务设计：SSP对服务的实现有详细的设计要求，服务设计过程中，需满足相应要求来实现SOA化。</p>
</li>
<li>
<p>服务实现：根据SSP提供的服务接口，完成接口实现的代码开发。</p>
</li>
<li>
<p>服务部署：SSP在设计之初就继承了跨平台属性，服务可根据实际使用情况，在不同环境、硬件、系统中部署一个或多个实例，以达到最大化的重用率。</p>
</li>
<li>
<p>服务管控：服务运行过程中，服务中的运行管理，包括服务状态管理、服务执行管理、相关的服务运行数据等，都可以被SSP监测到并通过收集到的数据判断服务的运行健康度，给服务乃至整个系统提供强有力的稳定、性能保证。除此之外，服务的权限配置也是很重要的考虑选项，服务发布后，可控制对外的授权管理，保证只有允许/授信的服务才可以使用服务。</p>
</li>
<li>
<p>ESB总线：SOA软件架构有个显著的特征，即服务中心化思想。服务之间的所有连接，均需通过ESB总线通讯。ESB总线名称上是通讯总线，但我们认为，应该把ESB称之为SOA服务中间件更恰当，ESB总线实现了以下几个特征：</p>
<ul>
<li>
<ol>
<li>所有服务间禁止任何形式的直接连接，唯一许可的通信方式，就是通过网络调用服务接口</li>
</ol>
</li>
<li>
<ol start="2">
<li>网络调用的具体实现方式不做强制要求，可根据不同系统的特性选择最优解决方案，目前支持Http、Binder、ZMQ、VIWI等，但均需支持以下能力：同步请求、异步请求、订阅、发布</li>
</ol>
</li>
<li>
<ol start="3">
<li>服务接口设计以可公开作为设计导向，即，所有的服务接口，必须是可以对外部人员开发的，没有例外。</li>
</ol>
</li>
<li>
<ol start="4">
<li>车云一体化软件组件</li>
</ol>
</li>
<li>
<ol start="5">
<li>实现车端—云端服务对等且位置无关化</li>
</ol>
</li>
<li>
<ol start="6">
<li>并针对不同车型配置，实现个性化配置管理及相应的服务管理</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="难点">难点</h4>
<p>通过SOA开发者平台孵化软件产品，开发者以及普通用户根据可调用服务，开发出各种应用。客观而言，用户在面对企业产品和技术时变成了主动活跃的一方。而车企由此加强和用户的联系，从面向用户封闭走向开放，无疑是为了建立智能汽车生态。</p>
<p>更高级的硬件架构、软件架构说到底只是带来效率更高的平台，到底最终能不能提供更丰富强大的功能、更好的用户体验，令生态活跃，关键在于上汽零束如何赋予平台健康的规则体系，平台运转起来才能体现价值。</p>
<p>简单来说就是，平台方要给我回报，我才愿意坚持干这事。其中有许多现实问题存在，比如车企如何吸引开发者入驻平台？车企如何吸纳更多友商融入平台？而再深层次看，开发者不仅需要明面上的利润分成，宝贵的数据资源同样不愿舍弃。</p>
<p>进一步要去思考的是，车企、生态参与方是否会将数据共享给开发者，这一点很难也很关键。如果数据无法流通形成闭环，开放平台的商业模式将很难建立。</p>
<h4 id="关于soa软件平台的思考">关于SOA软件平台的思考</h4>
<p>若背后的问题都努力解决后，仍有一个直击灵魂的疑问：SOA软件平台对于“软件定义汽车”而言，是否是决定性的因素，或者说不可或缺的角色？
客观而言，汽车需要的是一套可以很好的从全局优化汽车软件和性能，统筹软件和工具链的东西，让开发变得更高效更低成本。但严格意义讲，不以服务的方式，企业也依然可以实现各种前沿功能比如自动驾驶，给用户去体验。如果想要超越竞争对手，还要回到前沿领域去硬碰硬。</p>
<p>“软件定义汽车”这一发展趋势下，不会是过分强调SOA软件平台，而是将其作为部分。汽车最终会有一套最优化的软件平台、最匹配的操作系统、最适合的软件框架，各司其职并协同做好整车软件联动。若淡化这些部分，来落地SOA软件平台，效果可能不尽人意。</p>
<p>一直在说，SOA软件之于汽车，就好比App Store之于iPhone。当然，App Store的成功离不开软件开发，它真正创造了历史，但App Store的成功也离不开苹果的软硬一体化策略。产品在硬件上的高度一致性，随之带来了软件开发的超级便利，它成为开发者涌入的催化剂，真正推动了App Store由0到1。</p>
<p>所以回到汽车本身，软件定义汽车的全部，可能是要求车企站在整车架构的视角，运用软件思维，组织优化整车过去凌乱的逻辑关系，增强车端和云端的联动机制，最终来契合用户不断变化的功能需求。以上这些共同称为一项“事业”，而落地SOA软件平台，则是“事业”中的一项“KPI”。</p>
<p>目前来说，构建开放的平台，构建方便开发者、用户使用的开发工具，可以借势而起，但还需要更多努力。</p>
<h3 id="车云一体">车云一体</h3>
<h4 id="车云一体架构的需求背景">车云一体架构的需求背景</h4>
<p>随着时代的进步，技术的发展，不同主机厂商都大刀阔斧地开启了新四化的建设，再加上硬件技术日新月异的发展，使汽车这个具有空间属性的终端搭载了越来越多的硬件，让汽车的能力越来越多。同时，互联网技术的发展，5G高速网络的应用，车可以很方便地接入互联网，互联网赋能传统车辆更是大势所趋。</p>
<p>基于软件架构的思路，将车云能力高度抽象、车云融合、相互协调，并同步对外开放，形成车云一体架构。</p>
<p>车云一体架构实现车云协同，让车端可以自由使用云端服务，云端也可以方便地使用车端服务，使用者不用关心服务是在车端还是云端。从使用者、开发者以及OEM厂商的角度挖掘需求，提取能力共同特征，结合车云能力，形成车云一体架构，云为车赋能，车为人服务。</p>
<h4 id="车云一体架构的优势">车云一体架构的优势</h4>
<ol>
<li><strong>位置透明</strong>：车云服务的使用者不需要关心服务在车端还是云端，由平台自动完成服务的消费和响应；车端服务可以在云端访问，云端服务也可以在车端访问，形成车云一体化服务；</li>
<li><strong>可重用</strong>：车云一体化软件组件抽象实现，就可以方便地提供能力服务，可以被不同的上层抽象和使用，不同的车辆可以使用云端同一个软件组件提供的能力服务，车辆内部也可以很容易地实现跨域访问，而不需要重复地构建；</li>
<li><strong>易扩展</strong>：车云一体架构实现了组件的接口与实现分离，可以方便地进行实现的重构而不影响服务的消费者；也可以方便地进行云端、车端能力的扩展，通过服务发现的机制自动加入到SOA平台而不需要平台重构就可以向消费者提供服务；当然，还可以通过服务编排的机制根据不同的场景进行服务的调度和协调；方便进行扩展和使用；</li>
<li><strong>易使用</strong>：服务消费者只关心抽象服务的使用，而不用关心具体使用哪些车辆服务，这些服务是来自车端还是云端、也不用关心车辆服务的组合和协调调度，更不用关心服务的实现机制和原理；</li>
<li><strong>安全可控</strong>：通过访问权限暴露相关服务接口的机制，有效地控制了非法的访问，并且系统的安全机制和分层管控方法，更加方便地进行安全策略的控制和调整，保证了整个SOA平台的安全可靠；</li>
</ol>
<p>车云一体化软件组件的优势远不止于此，它解放了开发者的思维，提升了开发者对车辆的认识，可以让不同的角色聚焦到自己熟悉的领域，而屏蔽不必要的实现和部署细节，降低了上层应用对底层能力的依靠，解耦了不同功能组件的相互的依赖等等。</p>
<h4 id="车云一体的应用价值">车云一体的应用价值</h4>
<p>车云一体的基本概念，是车端的各ECU与云端之间基干SOA的设计思想以服务化的方式通信的软件架构。车内各ECU的服务抽象(如车门开关)与云端服务能力(如生态服务)通过统一的服务化协议完成车与云之间服务的自由调度，充分发挥整车各传感器/执行器与云平台服务能力组合带来的场景化优势，从而支撑OEM构建海量个性化的智能应用场景。</p>
<p>车云一体的应用价值如下：</p>
<ol>
<li>
<p><strong>OEM个性化智能场景的支撑</strong>
基于车云一体架构带来的服务化基础能力，实现车云SOA服务的高效稳定、协调工作，充分开发车辆硬件能力实现最大化功能和出行场景智能化，构建更贴近使用场景的智能化以及跨域创新组合的场景化应用(如车内摄像头疲劳检测和座椅震动的联动)，是支撑OEM打造智能汽车的核心技术架构，体现OEM品牌的个性化和差异化。</p>
</li>
<li>
<p><strong>云端与整车级系统联动能力的提升</strong>
得益于整车电子电器架构向以太网架构的进化，车内各域的系统级能力(如诊断、OTA、日志)也通过服务化封装方式的打通实现动态可配置，同时车内服务可以通过车云一体架构被云端发现和调度。因此，云端对于整车级数据采集、远程诊断/标定、整车OTA远程控车都可以通过服务化协议实现动态策略的能力提升，比如云端数据采集可指定采集的ECU采集的数据项、采集的频率、采集的策略(如时间周期)等。 </p>
</li>
<li>
<p><strong>支持新场景的快速迭代</strong>
基于车/云服务化的封装可以通过工具化、图形化、流程化的方式支撑新的功能场景的快速开发，面向不同技术背景人员也能够通过场景的企划设计，快速地完成制作。相比原有基于信号的开发模式通过封装好的服务进行组合可以大幅度提升开发效率，缩减开发周期，降低沟通成本，让持续的场景化服务成为OEM新的业务模式。帮助OEM快速应对市场对于智能化功能的需求变化，从而支撑软件服务围绕整车全生命周期服务的能力。</p>
</li>
<li>
<p><strong>OEM生态构建与服务运营支撑</strong>
相比于传统的车联网服务运营模式，车云一体带来的智能化的体验，将整车能力和互联网生态紧密的连接，无论从用户体验的提升(如音乐与氛围灯的联动还是面向普通车主的个性化场景功能编辑带来的可玩性都会激发车主用户的参与感从而提升付费意愿。另外，对于第三方开发者的能力开放，相比车机联网模式带来更多的能力提升，支撑更多智能化应用场景的价值创造，帮助OEM构建自己的软件服务生态，使软件收益成为OEM全新的商业模式。</p>
</li>
</ol>
<h4 id="车云一体注意点">车云一体注意点</h4>
<p>由于多层的安全控制、基于互联网的数据传输，这些都有可能增加系统的响应和延迟，对于一些时延要求较高的应用可能需要特殊的优化和处理；随着被管控车辆数量的增加，其并发的要求也必然增加，因此必须考虑云端服务的部署和扩展，尽可能避免单点故障，实现自动伸缩。车云一体架构也依赖网络的稳定，显然，网络的断开也必然影响服务的响应，因此，需要加大力度应对服务的治理，状态的跟踪，尽可能提升用户在使用上层应用时的体验。</p>
<hr>
<h3 id="基础知识积累">基础知识积累</h3>
<h4 id="车的基本数据">车的基本数据</h4>
<p>车的数据主要包含三类，一是车况数据，比如，加速、制动、驻车、档位、远近光/雾灯/位置灯、车窗、安全带、方向盘转角、方向盘转速、空调、音乐/FM/蓝牙、动力蓄电池电压电流温度、电机电压电流温度状态、发送机转速、发动机状态、怠速状态、节气门绝对位置、平均点火角度、主缸压力、进气温度、冷却液温度、ABS状态、EBD状态、ESP状态、车身稳定性控制状态、牵引力控制系统状态、警告信息。数据二是车辆的性能数据，比如油门踏板开度、制动踏板百分比、制动踏板状态、发动机转速、瞬时油耗、百公里油耗、剩余油量、百米加速；三是车辆使用的数据，里程、生命周期、行驶路段、行驶时间、行驶方向、行驶时段、行驶频次、单次行驶时长、拥堵时长、畅行时长、乘坐人数、进度/维度/海拔、翻滚角/俯仰角/横摆角、胎温/胎压、倒车雷达测距、探头、空调、车速/加速度、雨刷器状态。</p>
<h4 id="车联网涉及到的领域功能">车联网涉及到的领域功能</h4>
<ol>
<li>道路管理</li>
<li>信息管理</li>
<li>车辆管理</li>
<li>影音娱乐</li>
<li>健康与人身安全</li>
<li>自动驾驶</li>
<li>智能座舱</li>
</ol>
<h4 id="车联网三网融合">车联网三网融合</h4>
<ul>
<li><strong>车内网</strong>是汽车上应用成熟的总线技术建立起的标准化整车网络，在今天所有上路的汽车上都搭载有车内网，它以CAN/LIN网络为主，负责绝大多数车内传感器、执行器信号的传递。</li>
<li><strong>车载移动互联网</strong>是用户目前最能直接体验感受到的车联网，它指的是车辆通过CDMA/3G/4G的通讯技术与互联网进行无线连接，Carplay/OnStar/路宝目前都属于此列。</li>
<li><strong>车际网</strong>是基于无线局域网通讯协议建立的动态网络，包括V2V和V2I等，乃至拓展至V2X，车际网是实现网联汽车的最重要基础，是三网中里较为不成熟的一部分，也是各国各机构的研究热点。举例来说，绿灯亮起，等待的车辆经过车际网互联通讯，可以实现同时起步，提高了交通效率，这就是车际网的应用之一。</li>
</ul>
<h4 id="智能座舱的核心技术16类">智能座舱的核心技术16类</h4>
<table>
<thead>
<tr>
<th>技术</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>LCD/OLED液晶显示技术</td>
<td>硬件</td>
</tr>
<tr>
<td>超分辨率显示处理技术</td>
<td>软件</td>
</tr>
<tr>
<td>HUD抬头显示技术</td>
<td>硬件+软件</td>
</tr>
<tr>
<td>智能表面显示技术</td>
<td>软件</td>
</tr>
<tr>
<td>电子玻璃成像技术</td>
<td>硬件</td>
</tr>
<tr>
<td>全息投影显示</td>
<td>硬件+软件</td>
</tr>
<tr>
<td>AR融合显示技术</td>
<td>软件</td>
</tr>
<tr>
<td>视觉识别/分析技术</td>
<td>软件</td>
</tr>
<tr>
<td>语音交互技术（含生源定位）</td>
<td>软件</td>
</tr>
<tr>
<td>多媒体处理技术</td>
<td>软件</td>
</tr>
<tr>
<td>3D建模与成像技术</td>
<td>软件</td>
</tr>
<tr>
<td>车载操作系统（含虚拟化技术）</td>
<td>软件</td>
</tr>
<tr>
<td>座舱域计算平台（控制器）</td>
<td>硬件</td>
</tr>
<tr>
<td>座舱域电子架构EEA</td>
<td>硬件</td>
</tr>
<tr>
<td>多音区与主动降噪技术</td>
<td>软件</td>
</tr>
<tr>
<td>AI智能芯片技术</td>
<td>硬件</td>
</tr>
</tbody>
</table>
<h4 id="智能车联的核心技术8类">智能车联的核心技术8类</h4>
<table>
<thead>
<tr>
<th>技术</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>V2X车车、车路、车人互联技术</td>
<td>硬件+软件</td>
</tr>
<tr>
<td>FOTA/SOTA远程升级技术</td>
<td>软件</td>
</tr>
<tr>
<td>汽车信息安全技术</td>
<td>软件</td>
</tr>
<tr>
<td>云计算技术</td>
<td>硬件+软件</td>
</tr>
<tr>
<td>大数据分析技术</td>
<td>软件</td>
</tr>
<tr>
<td>车辆数据采集技术</td>
<td>软件</td>
</tr>
<tr>
<td>移动互联网技术</td>
<td>软件</td>
</tr>
<tr>
<td>多媒体传输技术</td>
<td>软件</td>
</tr>
</tbody>
</table>
<h4 id="学习参考链接">学习参考链接</h4>
<p><a href="https://www.woshipm.com/it/5235529.html">从互联网转行到汽车行业，你需要了解哪些知识？</a></p>
<p><a href="http://www.woshipm.com/it/5402837.html">关于智能汽车和车企产品经理的基础认知</a></p>
<p><a href="http://www.woshipm.com/pd/4860479.html">智能座舱系列一：智能化基础平台及架构</a></p>
<h4 id="术语解释">*术语解释</h4>
<p><strong>CP：</strong> Content Provider，即内容提供商。CP指内容的直接提供者,一般来讲,CP通过SP提供给他们的一些接口来完成内容信息的发布处理。</p>
<p><strong>SP：</strong> Service Provider，即服务提供商。指移动互联网服务内容应用服务的直接提供者，负责根据用户的要求还发和提供适合用户使用的服务</p>
<p><strong>POI：</strong> Point of Interest，可以翻译为“兴趣点”。在地理信息系统中，一个POI可以是一栋房子、一个商铺、一个邮筒、一个公交站等。</p>
<p><strong>ADAS：</strong> Advanced Driving Assistance System，高级驾驶辅助系统，是利用安装在车上的各式各样传感器（毫米波雷达、激光雷达、单\双目摄像头以及卫星导航），在汽车行驶过程中随时来感应周围的环境，收集数据，进行静态、动态物体的辨识、侦测与追踪，并结合导航地图数据，进行系统的运算与分析，从而预先让驾驶者察觉到可能发生的危险，有效增加汽车驾驶的舒适性和安全性。</p>
<p><strong>IVI：</strong> In-Vehicle Infotainment，车载信息娱乐系统，是采用车载专用中央处理器，基于车身总线系统和互联网服务，形成的车载综合信息处理系统。IVI能够实现包括三维导航、实时路况、IPTV、辅助驾驶、故障检测、车辆信息、车身控制、移动办公、无线通讯、基于在线的娱乐功能及TSP服务等一系列应用，极大的提升了车辆电子化、网络化和智能化水平。</p>
<p><strong>OTA：</strong> Over-the-Air Technology，空中下载技术，即车辆自身的系统可以在线升级</p>
<p><strong>V2X：</strong> vehicle to everything，即车对外界的信息交换。车联网通过整合全球定位系统（GPS）导航技术、车对车交流技术、无线通信及远程感应技术奠定了新的汽车技术发展方向，实现了手动驾驶和自动驾驶的兼容。简单来说，搭配了该系统的车型，在自动驾驶模式下，能够通过对实时交通信息的分析，自动选择路况最佳的行驶路线，从而大大缓解交通堵塞。除此之外，通过使用车载传感器和摄像系统，还可以感知周围环境，做出迅速调整，从而实现“零交通事故”。例如，如果行人突然出现，可以自动减速至安全速度或停车。</p>
<p><strong>ECU：</strong> Electronic Control Unit，即电子控制单元，也可以叫 “行车电脑”。决定整车性能的最重要的部分就是它的ECU。作为现代汽车电子的核心元件之一 ，ECU电子控制单元在汽车中也许有好几个，每个管理不同的功能；而每个ECU系统之间又有信息交换。虽然在整车上的控制系统越来越复杂，但它仍然必须具备最基本的结构—微处理器（CPU）、存储器（ROM、RAM）、输入/输出接口(I/O)、模数转换器(A/D)以及整形、驱动等大规模集成电路。</p>
<p><strong>MCU：</strong> Micro Controller Unit，即微控制单元，又称单片微型计算机(Single Chip Microcomputer)，是指随着大规模集成电路的出现及其发展，将计算机的CPU、RAM、ROM、定时数器和多种I/O接口集成在一片芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制。</p>
<p><strong>BCM：</strong> 车身控制模块，主要功能是实现离散的控制功能，对众多用电器进行控制。主要控制汽车车身用电器，如灯具、雨刮、门锁、电动窗、天窗等。就是这些用电器的开关信号输入给BCM，BCM直接或通过继电器控制相应电器工作。</p>
<p><strong>AUTOSAR：</strong> AUTomotive Open System Architecture，汽车开放系统架构，AUTOSAR是由全球汽车制造商、部件供应商及其他电子、半导体和软件系统公司联合建立，各成员保持开发合作伙伴关系。自2003年起，各伙伴公司携手合作，致力于为汽车工业开发一个开放的、标准化的软件架构。AUTOSAR这个架构有利于车辆电子系统软件的交换与更新，并为高效管理愈来愈复杂的车辆电子、软件系统提供了一个基础。此外，AUTOSAR在确保产品及服务质量的同时，提高了成本效率。</p>
<p><strong>新四化：</strong> 电气化、网络化、智能化、共享化。电气化是指新能源电力系统领域；智能化是指无人驾驶或驾驶辅助子系统；联网是指车联网的布局；共享是指汽车共享和移动旅行。</p>
<p><strong>GEEP 3.0、4.0、5.0：</strong> 2020年，长城汽车开发出GEEP 3.0电子电气架构，从分布式架构转转成功能域架构，将架构调整为车身控制、动力底盘、智能座舱、智能驾驶4个域控制器，实现软件自主。目前GEEP 3.0已经应用在长城汽车的全系车型上。
为了进一步集中整车控制软件，实现高效集成管理、高度安全可靠和更快需求响应，长城汽车再一次将整车软、硬件高度整合，形成了基于中央计算和区域控制的下一代全新电子电气架构—GEEP 4.0。
全新电子电气架构采用SOA（面向服务的架构）设计理念，开放标准API（应用程序编程接口），全面满足用户智能化需求。预计将于明年推出，并率先搭载到长城汽车全新电动、混动平台，后续扩展到旗下全系车型。
更高一级的GEEP 5.0的研发也与GEEP 4.0同步启动，GEEP 5.0将实现全车只有一个大脑，完全形成智能机器人，100%SOA化，全面完成整车标准化软件平台的搭建，并将于2024年实现产品落地。</p>
<p><strong>TSP：</strong> Telematics Service Provider，汽车远程服务提供商，在Telematics产业链居于核心地位，上接汽车、车载设备制造商、网络运营商，下接内容提供商。Telematics服务集合了位置服务、Gis服务和通信服务等现代计算机技术，为车主和个人提供强大的服务：导航、娱乐、资讯、安防、SNS、远程保养的。除专门的TSP平台服务商（如休斯、飞驰镁物等）外，目前，许多第三方服务商（如整车厂商、电信运营商、互联网内容服务商等）亦开始进入TSP领域，构建属于自己的TSP平台。</p>
]]></content>
		</item>
		
		<item>
			<title>个人常用的 Docker 镜像安装记录</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/docker-study-note/</link>
			<pubDate>Wed, 10 Nov 2021 00:59:02 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/docker-study-note/</guid>
			<description>0. Portainer a. 创建 Portainer Server 将用于存储其数据库的卷： docker volume create portainer_data b. 下载并安装 Portainer Server 容器： docker run -d -p 9000:9000 --name portainer \ --restart=always \ -v /var/run/docker.sock:/var/run/docker.sock \ -v portainer_data:/data \ portainer/portainer-ce:latest 1. Epic 周免游戏自动领取 首先创建 docker-compose.yml 文件，内</description>
			<content type="html"><![CDATA[<h2 id="0-portainer">0. Portainer</h2>
<h3 id="a-创建-portainer-server-将用于存储其数据库的卷">a. 创建 Portainer Server 将用于存储其数据库的卷：</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker volume create portainer_data
</code></pre></div><h3 id="b-下载并安装-portainer-server-容器">b. 下载并安装 Portainer Server 容器：</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker run -d -p 9000:9000 --name portainer <span class="se">\
</span><span class="se"></span>    --restart<span class="o">=</span>always <span class="se">\
</span><span class="se"></span>    -v /var/run/docker.sock:/var/run/docker.sock <span class="se">\
</span><span class="se"></span>    -v portainer_data:/data <span class="se">\
</span><span class="se"></span>    portainer/portainer-ce:latest
</code></pre></div><hr>
<h2 id="1-epic-周免游戏自动领取">1. Epic 周免游戏自动领取</h2>
<p>首先创建 docker-compose.yml 文件，内容如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">epic-a</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">luminoleon/epicgames-claimer</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">epic-a</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">      </span>- <span class="l">AUTO_UPDATE=true</span><span class="w">
</span><span class="w">      </span>- <span class="l">EMAIL=邮箱</span><span class="w">
</span><span class="w">      </span>- <span class="l">PASSWORD=密码</span><span class="w">
</span><span class="w">  </span><span class="nt">epic-b</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">luminoleon/epicgames-claimer</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">epic-b</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">      </span>- <span class="l">AUTO_UPDATE=true</span><span class="w">
</span><span class="w">      </span>- <span class="l">EMAIL=另一个邮箱</span><span class="w">
</span><span class="w">      </span>- <span class="l">PASSWORD=另一个密码</span><span class="w">
</span></code></pre></div><p>然后执行命令:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose up -d
</code></pre></div><hr>
<h2 id="2-vaultwarden原-bitwarden">2. Vaultwarden（原 Bitwarden）</h2>
<h3 id="a-映射文件目录创建">a. 映射文件目录创建</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">mkdir -p /usr/local/apps/vaultwarden/data  /usr/local/apps/nginx/conf.d /usr/local/apps/nginx/ssl
touch /usr/local/apps/vaultwarden/.env /usr/local/apps/nginx/conf.d/bitwarden.conf
</code></pre></div><h3 id="b-创建-docker-compose-文件">b. 创建 Docker compose 文件</h3>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3.3&#39;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">nginx</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx:stable</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/usr/local/apps/nginx/conf.d:/etc/nginx/conf.d</span><span class="w">
</span><span class="w">      </span>- <span class="l">/usr/local/apps/nginx/ssl:/etc/ssl</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;59995:443&#34;</span><span class="w">
</span><span class="w">
</span><span class="w"> </span><span class="nt">vaultwarden</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">vaultwarden/server:latest</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">bitwarden</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/usr/local/apps/vaultwarden/data:/data/</span><span class="w">
</span><span class="w">      </span>- <span class="l">/usr/local/apps/vaultwarden/.env:/.env</span><span class="w"> </span><span class="c">#从.env文件中加载环境变量 </span><span class="w">
</span><span class="w">
</span><span class="w">
</span></code></pre></div><h3 id="c-修改-vaultwarden-的配置文件-env">c. 修改 Vaultwarden 的配置文件 <code>.env</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">SIGNUPS_ALLOWED</span><span class="o">=</span><span class="n">false</span>  <span class="c1"># 是否开放注册，个人使用建议否</span>
<span class="n">ADMIN_TOKEN</span><span class="o">=</span><span class="mi">123456</span>  <span class="c1"># 自行设置后台管理密码</span>
</code></pre></div><p>然后执行命令:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose up -d
</code></pre></div><h3 id="d-配置-nginx-文件存放在本地映射文件夹下">d. 配置 Nginx 文件，存放在本地映射文件夹下</h3>
<div class="highlight"><pre class="chroma"><code class="language-nginx" data-lang="nginx"><span class="k">server</span> <span class="p">{</span>
  <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>
  <span class="kn">server_name</span> <span class="s">your.domin</span><span class="p">;</span> <span class="c1">#修改域名
</span><span class="c1"></span>
  <span class="kn">ssl_certificate</span>      <span class="s">/etc/ssl/certs/yourkeyname.pem</span><span class="p">;</span>   
  <span class="kn">ssl_certificate_key</span>  <span class="s">/etc/ssl/certs/yourkeyname.key</span><span class="p">;</span> 


  <span class="c1"># Allow large attachments
</span><span class="c1"></span>  <span class="kn">client_max_body_size</span> <span class="s">128M</span><span class="p">;</span>

  <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
    <span class="c1">#个人修改容器内 Vaultwarden 的ip及端口，不知道规不规范，请指正
</span><span class="c1"></span>    <span class="kn">proxy_pass</span> <span class="s">http://172.19.0.3:80</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-For</span> <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-Proto</span> <span class="nv">$scheme</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kn">location</span> <span class="s">/notifications/hub</span> <span class="p">{</span>
    <span class="c1">#websocket 端口
</span><span class="c1"></span>    <span class="kn">proxy_pass</span> <span class="s">http://172.19.0.3:3012</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
    <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">&#34;upgrade&#34;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kn">location</span> <span class="s">/notifications/hub/negotiate</span> <span class="p">{</span>
    <span class="c1">#个人修改容器内 Vaultwarden 的ip及端口，不知道规不规范，请指正
</span><span class="c1"></span>    <span class="kn">proxy_pass</span> <span class="s">http://172.19.0.3:80</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>重启 Nginx 容器即可生效</p>
<hr>
<h3 id="3-heimdall-导航">3. Heimdall 导航</h3>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2.1&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">heimdall</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">lscr.io/linuxserver/heimdall</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">heimdall</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">&lt;/path/to/appdata/config&gt;:/config</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">80</span><span class="p">:</span><span class="m">80</span><span class="w">
</span><span class="w">      </span>- <span class="m">443</span><span class="p">:</span><span class="m">443</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></code></pre></div><blockquote>
<p>需要以非 root 用户部署</p>
</blockquote>
<hr>
<h3 id="4-为知笔记-wiz放弃折腾">4. 为知笔记 Wiz（放弃折腾）</h3>
<blockquote>
<p>不知道什么原因手机 4G 网络访问不了，并且容器占用资源多，暂时放弃折腾，需要的话先用 Coding 在线编辑器对付用一下，或着有空试一下 Joplin</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker run --name wiz --restart<span class="o">=</span>always -it -d -v  ~/wizdata:/wiz/storage -v  /etc/localtime:/etc/localtime -p 80:80 -p 9269:9269/udp  wiznote/wizserver
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>【已失效】腾讯云部署（几乎）白嫖 Bitwarden</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/bitwarden/</link>
			<pubDate>Mon, 01 Nov 2021 22:18:39 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/bitwarden/</guid>
			<description>0. 前言 随着在大大小小各式各样网站注册的账号增多，需要记下的账号密码也特别容易忘记，况且所有网站都用相同的用户名密码特别不安全。这时需要小本本</description>
			<content type="html"><![CDATA[<h2 id="0-前言">0. 前言</h2>
<p>随着在大大小小各式各样网站注册的账号增多，需要记下的账号密码也特别容易忘记，况且所有网站都用相同的用户名密码特别不安全。这时需要小本本挨个几下，确实很麻烦，随身携带个小本本确实也不方便，因此利用密码管理工具就显得尤为重要。这类工具的老大 1Password 闭源且收费，再说了为了保管密码一个月十块二十块的也没大必要，而 Bitwarden 则是一个免费、跨平台，且可以私有化部署的开源密码管理工具。</p>
<p>部署 Bitwarden 的方式可以是本地服务器 nas 之类的，也可以在云服务器上部署，具体方法网上能搜一大堆。但这些方式还是有一些数据安全的不确定性，比如 nas 的硬盘挂了。相比之下，用腾讯云部署并托管还是比较安全可靠的方式（别欠费就行），且几乎能白嫖，不需要自己的服务器，不会浪费自己服务器的资源，因此选用这种方式部署 Bitwarden 是个人最喜欢的。</p>
<h2 id="1-准备">1. 准备</h2>
<ul>
<li>腾讯云实名认证账号</li>
<li>一点耐心</li>
</ul>
<h2 id="2-步骤">2. 步骤</h2>
<h3 id="i">I</h3>
<p>访问<a href="https://github.com/hang666/bitwarden">https://github.com/hang666/bitwarden</a></p>
<p>Vaultwarden 基于云开发部署项目，支持一键云端部署，访问后点击<strong>SQLite 部署（文件存储）</strong> 后的部署按钮即可跳转到腾讯云部署配置页面，一般个人使用的话 SQLite 就够用了，不需要 Mysql ，使用 Mysql 会额外收费。</p>
<h3 id="ii">II</h3>
<p>后续跟着步骤走：选择地域，起一个环境名称，记得勾选「开启免费资源」，确定授予权限，点击完成，等待两三分钟后部署成功。</p>
<h3 id="iii">III</h3>
<p>部署成功后，在<strong>我的应用</strong>内找到链接并访问，即可进入到 Vaultwarden ，创建账号。</p>
<h3 id="iiii">IIII</h3>
<p>创建完账号后，回到腾讯云开发，点击左侧云托管，选择 bitwarden 服务，选择版本，在下方配置信息模块选择「编辑配置并重新部署」，将环境变量修改为（报错把 # 去掉）：</p>
<pre><code>{
  &quot;TCB_COMMIT_ID&quot;: &quot;&quot;,
  &quot;WEBSOCKET_ENABLED&quot;: &quot;false&quot;,
  &quot;ADMIN_TOKEN&quot;: &quot;aaaaaa&quot;, #管理员密码自行修改
  &quot;SIGNUPS_ALLOWED&quot;: &quot;false&quot; #建议不开放注册
}
</code></pre><p>保存并重新部署</p>
<p>这样，通过访问 /admin 即可进入到管理后台</p>
<h2 id="3-客户端下载">3. 客户端下载</h2>
<p>由于官网 <a href="https://www.bitwarden.com">https://www.bitwarden.com</a> 由于某些原因无法访问，建议不要随便在网上搜索下载，而是去官方的 Github 页下载，个人使用较多的是 Chrome 的插件版及安卓 app ，下面贴俩地址，其他的请自行寻找。</p>
<p><a href="https://github.com/bitwarden/browser/releases">浏览器插件</a></p>
<p><a href="https://github.com/bitwarden/mobile/releases">移动端 app</a></p>
]]></content>
		</item>
		
		<item>
			<title>Kegin T201p</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/kegin-t201p/</link>
			<pubDate>Thu, 09 Sep 2021 18:27:49 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/kegin-t201p/</guid>
			<description>当我发现我想写日记的时候，就总要逼迫自己用特别正式的口吻去表达，这样的思想成为了我记录文字的枷锁，本身这些内容就是写给自己看的，不必那么认真</description>
			<content type="html"><![CDATA[<blockquote>
<p>当我发现我想写日记的时候，就总要逼迫自己用特别正式的口吻去表达，这样的思想成为了我记录文字的枷锁，本身这些内容就是写给自己看的，不必那么认真，我就应该想说啥就说啥</p>
</blockquote>
<h2 id="0-前言">0. 前言</h2>
<p>先说一下接触 nas 的经历，之前大概 17 年在北京跟张鹏纪傲一起住的时候，我们一起办了联通宽带，送了一台 IPTV 的盒子，这种盒子与其他的电视盒子一样，本身就有安装安卓视频软件的功能，奈何宽带运营商的盒子把这部分功能阉割了，于是我就开始折腾刷机，这台北京联通 Q5 的芯片是 S905 系列，因为有很多款，当时为了找兼容的刷机包还费了很大劲。结果盒子在我疯狂的折腾下，并不怎么好用，反而失去了原有的 IPTV 看电视直播的体验，虽然大伙其实都不怎么看电视，但其实还是给大家造成了一点小影响。</p>
<p>21 年 3 月份偶然得知，这种 Q5 盒子可以刷 Armbian 系统，也就是专为 arm 芯片重新编译的 Debian系统，这又重拾了我想了解 Linux 的热情，于是淘了一个二手的盒子，进行尝试，从此折腾 nas 的种子开始埋下。</p>
<p>也是在 21 年的 3 月份，在某论坛看到腾讯云的云服务器，折扣价很便宜，2C-4G-80G-6M（之后免费升级到 8M）的配置大概是 400 左右 3 年，也不知道怎么想的，在生活很拮据的时候买了它。腾讯轻量云提供的镜像不仅包含 Ubuntu、CentOS、Debian 等系统镜像，也了解了 Docker 还有安装好宝塔、Cloudreve、Nextcloud 等应用型镜像，在这里我第一次了解到宝塔这种服务器可视化运维，也第一次知道可以私有部署的开源云盘项目。但是用轻量云安装 Cloudreve 实际使用容量也只有80G，何不用电视盒子利用家里的带宽部署自己的云盘？</p>
<p>Q5 盒子在实际使用上有太多局限，折腾一阵之后，开始物色其他垃圾产品，玩客云据说偷跑上传而且刷机麻烦，蜗牛星际和暴风酷播云这种矿渣价格已经起飞，最终选择了著名的理财产品斐讯 N1。</p>
<blockquote>
<p>未完待续……</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>利用 Gooreplacer 解决 reCAPTCHA 无法显示的问题</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/ues-gooreplacer-to-display-recaptcha/</link>
			<pubDate>Sat, 04 Sep 2021 12:44:00 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/ues-gooreplacer-to-display-recaptcha/</guid>
			<description>0. 前言 对于某些网站登录注册，需要使用 reCAPTCHA 进行验证。reCAPTCHA 是谷歌的验证码服务，众所周知，没有这个网站，所以验证码无法加载。那么该如何</description>
			<content type="html"><![CDATA[<h2 id="0-前言">0. 前言</h2>
<p>对于某些网站登录注册，需要使用 reCAPTCHA 进行验证。reCAPTCHA 是谷歌的验证码服务，众所周知，没有这个网站，所以验证码无法加载。那么该如何解决呢？</p>
<p>Gooreplacer 是一个用来重定向/屏蔽 URL 的浏览器插件，我们把国内无法访问的 <code>www.google.com/recaptcha</code> 重定向为国内能够访问的 <code>recaptcha.net/recaptcha</code> 使得验证码可以加载。</p>
<p><img src="/image/ues-gooreplacer-to-display-recaptcha/gooreplacer-preview.png" alt="alt Gooreplacer" title="Gooreplacer 预览"></p>
<h2 id="1-下载及安装">1. 下载及安装</h2>
<h3 id="方法一插件商店安装">方法一：插件商店安装</h3>
<p>不多赘述，Firefox 浏览器、EDGE 浏览器可直接到扩展商店下载安装，Chrome 自己想办法进应用商店</p>
<h3 id="方法二扩展包文件下载安装">方法二：扩展包文件下载安装</h3>
<p><a href="https://github.com/jiacai2050/gooreplacer/releases">Github下载链接</a></p>
<p>下载好 zip 文件后，本地解压。之后在 <code>chrome://extensions/</code> 选中开发者模式，选择「加载已解压的扩展程序」即可。</p>
<h2 id="2-设置规则加载-recaptcha">2. 设置规则加载 reCAPTCHA</h2>
<p>点击添加按钮，填入信息，保存提交：</p>
<p>匹配模式：</p>
<pre><code>www.google.com/recaptcha
</code></pre><p>目标地址：</p>
<pre><code>recaptcha.net/recaptcha
</code></pre><h2 id="3-拓展">3. 拓展</h2>
<p>知道了 Gooreplacer 的作用，可以用它来重定向谷歌资源如字体、API等提高网页访问速度。具体使用方法请参考作者的 Github 学习更多。</p>
<blockquote>
<p><a href="https://github.com/jiacai2050/gooreplacer">作者jiacai2050</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/jiacai2050/gooreplacer/blob/master/doc/guides.md">自动跳转知乎链接、防运营商劫持</a></p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>利用 Cloud Studio 云端搭建 Hugo 博客</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/cloud-studio-hugo/</link>
			<pubDate>Mon, 26 Apr 2021 17:31:02 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/cloud-studio-hugo/</guid>
			<description>需求 之前在 Linux 上部署了 Hugo 的博客，发现我需要在不同设备上都安装 Hugo，而且是在不同的环境下，就显得很麻烦，即便可以通过 Github 同步博客的源文件，但还</description>
			<content type="html"><![CDATA[<h3 id="需求">需求</h3>
<p>之前在 Linux 上部署了 Hugo 的博客，发现我需要在不同设备上都安装 Hugo，而且是在不同的环境下，就显得很麻烦，即便可以通过 Github 同步博客的源文件，但还是感觉麻烦，用一台服务器的话又闲贵，所以想到了下面的方法</p>
<h3 id="想法">想法</h3>
<p><a href="https://coding.net/">Coding</a> 的 Cloud Studio 具体就不介绍了，去搜把，就是在浏览器运行 VS Code ，可以编写、调试代码，内置 Linux 环境终端，刚好可以利用这个功能来安装 Hugo 实现在线撰写并部署，类似于一台云主机</p>
<h3 id="思路">思路</h3>
<p>注册Coding，进入到个人控制面板，在左侧选择 <code>Cloud Studio</code> 进入到在线 IDE 的界面，新建一个<code>工作空间</code>，运行环境选择<code>内置环境</code>，后面需要的环境按需求选择，我选的就是 Ubuntu 18.04，确认后就进入到在线的 IDE 界面了，上方菜单选择<code>终端</code>-&gt;<code>新终端</code>，接下来的操作就参考上一篇内容<a href="https://xn--4gq986klnp.cn/posts/hugo-github-personalblog/">《Hugo+Github Pages 搭建个人博客手记萌新向》</a>像新机器一样操作就好了</p>
<h3 id="结语">结语</h3>
<p>Cloud Studio 对于开发者来说确实是个不错的工具，对于不会开发的我也有其利用价值，它的功能相当于免费获得了一台云主机，不再受地点，设备所约束，源文件也保存在远程的服务器上，内置在线版 VS Code 可以安装 Markdown 插件使写作更加便捷，虽然每天只有4小时的可用时间，但对于我来说已经是足够用了，感谢技术</p>
]]></content>
		</item>
		
		<item>
			<title>Hugo&#43;Github Pages 搭建个人博客手记萌新向</title>
			<link>https://blog.xn--4gq986klnp.cn/posts/hugo-github-personalblog/</link>
			<pubDate>Mon, 19 Apr 2021 21:23:20 +0800</pubDate>
			
			<guid>https://blog.xn--4gq986klnp.cn/posts/hugo-github-personalblog/</guid>
			<description>0. 前言 记得在19年那段时间，在无意间了解到 Github Pages 可以托管静态页面作为个人博客站，于是开始兴致勃勃研究了一会，新鲜几天之后，搭建完毕，还绑了自己</description>
			<content type="html"><![CDATA[<h2 id="0-前言">0. 前言</h2>
<p>记得在19年那段时间，在无意间了解到 Github Pages 可以托管静态页面作为个人博客站，于是开始兴致勃勃研究了一会，新鲜几天之后，搭建完毕，还绑了自己名字的域名，就扔在那了，一篇内容都没有写。随着时间的推移，Hexo 该怎么使用，用哪些 git 命令已经忘得一干二净了。</p>
<p>然而最近又有了维护一个自己博客的冲动，然而安装 Hexo 并没我记忆中的那么顺利，让我不得不放弃 Hexo 而选择其他工具，最终确定 Hugo（主要是喜欢 Hugo 的这个主题），所以本篇我就记录一下我利用 Hugo 搭建个人博客的过程</p>
<p>但是我这次先把内容先写一部分再开始着手做搭建，一是不想让这次博客又白白搭建，二是作为以后使用的备忘手记（记性不好），其中参考了网上一些大神的教程及脚本，想详细学习的话推荐去看他的教程</p>
<blockquote>
<p><strong>Berlin</strong>
<a href="https://fengberlin.github.io/post/use-hugo-to-build-blog/">https://fengberlin.github.io/post/use-hugo-to-build-blog/</a></p>
</blockquote>
<h2 id="1-介绍">1. 介绍</h2>
<p>原理：利用工具将写作内容（Markdown）生成 HTML 静态页，将静态页上传至 Github，利用 Github Pages 的页面链接进行访问</p>
<h3 id="markdown">Markdown</h3>
<p>是一种轻量级标记语言,它允许人们使用易读易写的纯文本格式编写文档，由于 Markdown 的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。Markdown 的优势是可以利用一些简单的语法实现排版功能，没有那么多排版、字体的设置，简介易用。弄这些的人基本应该会懂把，懂洞东懂，不懂<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=markdown&amp;fenlei=256&amp;rsv_pq=dd688735000c19e5&amp;rsv_t=2df9kErCKYlOFqkZeoc6GLt4RRdD%2BTOq151y9yITY%2Bzy04gDNpDx8sx51Vs&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=7&amp;rsv_sug1=3&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=2619&amp;rsv_sug4=2619&amp;rsv_sug=2">去搜</a>。</p>
<h3 id="静态页博客生成工具">静态页博客生成工具</h3>
<p>Hugo、Hexo、Jekyll、Gridea 是我所了解到比较常用的工具，当然，可能还有一些更热门更好用的工具只是我不知道而已</p>
<p>我只用过 Hexo 和 Hugo，之前用的是 Hexo，这次搭建用的是 Hugo，简要总结一下我对这俩工具的个人感受：</p>
<p>Hugo：</p>
<pre><code>+社区环境很好
+生成网站速度超快
+更简单轻量，能够让人更专注于写作
+个人更喜欢 Hugo 的主题
-每次写完都要删除 public 文件夹
-扩展性稍差
</code></pre>
<p>Hexo：</p>
<pre><code>+功能性、可扩展性强
+部署命令相对简洁
+也有很多不错的主题
-在配置 hexo 出现各种各样的问题（98.735%是我哪里没弄好）
</code></pre>
<p>其他的我也没使用过，想要了解的话<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=Jekyll%20Gridea&amp;fenlei=256&amp;rsv_pq=b1250ae500089051&amp;rsv_t=2bd8lZm6jmg6wcCXNtnKNqA2Um1IPCKWY9BCSNcoTfm%2FA7U9%2Bi4FDSvbjoU&amp;rqlang=cn&amp;rsv_dl=tb&amp;rsv_enter=1&amp;rsv_sug3=5&amp;rsv_sug1=1&amp;rsv_sug7=001&amp;rsv_n=2&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=10381&amp;rsv_sug4=10442&amp;rsv_sug=9">去搜</a></p>
<h3 id="github-pages">Github Pages</h3>
<p><a href="https://pages.github.com/">https://pages.github.com/</a> 介绍就不说了，看看就知道了</p>
<h2 id="2-部署过程">2. 部署过程</h2>
<h3 id="注册-github-并建立项目">注册 Github 并建立项目</h3>
<p>注册不说了
登录 Github，新建 repository，名称为 <code>&lt;username&gt;.github.io</code>（必须），作为 Github Pages 的页面地址
例如 Github 的用户名是 zhang3，则新建的项目名称为: <code>zhang3.github.io</code></p>
<p>再创建一个 repository，名称为 myhugo（任意），作为存放除了生成静态页以外的所有文件（例如 <code>config.toml</code> 配置文件等），这样即便本地原始文件清空了，或者更换设备时，都可以把源文件迁移过来（我之前用 hexo 的时候就没同步）</p>
<h3 id="安装-git已有请忽略">安装 git（已有请忽略）</h3>
<p>首先安装 git</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt-get install git -y
</code></pre></div><p>配置 Github 用户信息</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git config –-global user.name username    <span class="c1"># username填写Github用户名</span>
git config –-global user.email user@useremail.com    <span class="c1"># useremail填写Github用户名关联的邮箱地址</span>
</code></pre></div><p>生成 <code>ssh key</code> 关联 Github</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">ssh-keygen -t rsa -C “your_email@youremail.com” <span class="c1">#youremail填写Github用户名关联的邮箱地址</span>
</code></pre></div><p>三下回车后，会在根目录生成一个<code>.ssh</code>的文件夹，</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">cat ~/.ssh/id_rsa.pub
</code></pre></div><p>复制公钥的内容，登录 Github，点击头像 -&gt; Settings —&gt; SSH and GPG keys —&gt; New SSH key，把公钥的内容粘贴到 key 中，填好 title 并点击 Add SSH key
至此，关联完毕</p>
<p>测试是否关联成功</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">ssh git@github.com
</code></pre></div><p>若返回显示您的用户名即为关联成功</p>
<h3 id="hugo安装包下载">Hugo安装包下载</h3>
<p>我用的系统是 Ubuntu，其他系统例如 MacOS、Win、其他发行版 Linux 系统除了获取 Hugo 的方式稍有不同之外，几乎没有差别</p>
<p>利用 apt-get 方式安装的 Hugo 版本比较旧，达不到很多主题所要求的最低标准，所以我们选择在 GitHub 上下载最新版本的安装包</p>
<p>Hugo 安装包下载地址
<a href="https://github.com/gohugoio/hugo/releases">https://github.com/gohugoio/hugo/releases</a></p>
<h3 id="安装-hugo">安装 Hugo</h3>
<p>执行命令</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo dpkg -i &lt;文件名.deb&gt;
</code></pre></div><blockquote>
<p>dpkg 软件包管理器，-i 安装</p>
</blockquote>
<p>可能会报依赖关系的错误，执行命令修复安装</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt-get install -f
</code></pre></div><blockquote>
<p>-f : &ndash;fix-broken 的简写形式，修复依赖关系(depends)的命令</p>
</blockquote>
<h3 id="初始化-hugo">初始化 Hugo</h3>
<p>先 cd 到想要创建博客文件夹的上一级，尔后执行</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo new site myblog  <span class="c1"># myblog就是生成博客之后存放的文件夹</span>
</code></pre></div><p>Hugo 会自动创建 <code>myblog</code> 文件夹并生成需要的文件</p>
<h3 id="安装主题">安装主题</h3>
<p><a href="https://themes.gohugo.io">https://themes.gohugo.io</a> Hugo 官方汇总的主题列表，可以去看看，很多主题都有demo可以预览一下，主题的使用教程都比较详细</p>
<p>例如安装 Notepadium 主题 <a href="https://themes.gohugo.io/hugo-notepadium/">https://themes.gohugo.io/hugo-notepadium/</a></p>
<p>在 <code>myblog</code> 目录下，输入 git 命令,</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git submodule add https://github.com/cntrump/hugo-notepadium.git themes/hugo-notepadium
</code></pre></div><blockquote>
<p>git submodule add &lt;仓库地址&gt; &lt;本地路径&gt; ：Git Submodule 允许一个 git 仓库，作为另一个 git 仓库的子目录</p>
</blockquote>
<p>以后更新主题可以使用命令</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git submodule update --remote --merge
</code></pre></div><p>因为主题中配置文件更易用，所以将主题目录中 <code>exampleSite</code> 的 <code>config.toml</code> 复制到 <code>myblog</code> 的目录下进行配置</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">mv config.toml config.toml.old
mv themes/hugo-notepadium/exampleSite/config.toml config.toml
</code></pre></div><p>具体配置请参考每个主题下的介绍内容或者<a href="https://www.baidu.com/s?ie=utf-8&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=hugo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&amp;fenlei=256&amp;rsv_pq=f5192e0f000cf9fe&amp;rsv_t=25f0gQhKS91drcQT4D%2BGMV1YZbAxF6mz1jJJYvIldwLbvEV1C1MKcnKUCNM&amp;rqlang=cn&amp;rsv_dl=ts_1&amp;rsv_enter=1&amp;rsv_sug3=12&amp;rsv_sug1=9&amp;rsv_sug7=101&amp;rsv_sug2=1&amp;rsv_btype=i&amp;prefixsug=hugo%2520peizhi&amp;rsp=1&amp;inputT=4189&amp;rsv_sug4=5196">去搜</a></p>
<h3 id="创建一篇文章">创建一篇文章</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo new post/firstblog.md
</code></pre></div><p>则会在<code>content/</code>目录内生成一个<code>post</code>文件夹，该文件夹就是用来存储你所创建编写的markdown文档</p>
<h3 id="生成博客">生成博客</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo server -D
</code></pre></div><blockquote>
<p>server 建立服务器   -D 生成静态页面文件（包括标记为草稿的内容）</p>
</blockquote>
<p>输入后访问<a href="http://localhost:1313">http://localhost:1313</a> 即可在本地看到生成博客的页面效果</p>
<h3 id="推送到-github上以下很多内容摘抄自berlin的博客">推送到 Github上（以下很多内容摘抄自<strong>Berlin</strong>的博客）</h3>
<p>这里主要说推送到个人主页的方式</p>
<p>首先，需要把 <code>public/</code> 目录删除</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">rm -rf public/
</code></pre></div><p>把 <code>public/</code> 目录添加为 <code>submodule</code></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git init git submodule add git@github.com:XXX/xxx.github.io public <span class="c1"># xxx是Github的username</span>
</code></pre></div><blockquote>
<p>此处有个坑就是本机 git 默认分支名是 master，而 Github 中默认分支名已改成了main，因此需要把本地分支名称改为main</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git branch -m main
</code></pre></div><p>添加文件添加 <code>.gitignore</code> 文件，文件中写 <code>public/</code>，在同步到 myhugo 时会忽略 <code>public</code> 文件夹</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">vi .gitignore
public/
</code></pre></div><p>:wq 保存退出</p>
<p>将静态页上传到 <code>用户名.github.io</code> 的工作可以借助一个 <code>deploy.sh</code> 脚本来完成</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[0;32mDeploying updates to GitHub...\033[0m&#34;</span>

<span class="c1"># Build the project.</span>
hugo <span class="c1"># if using a theme, replace with `hugo -t &lt;YOURTHEME&gt;`</span>

<span class="c1"># Go To Public folder</span>
<span class="nb">cd</span> public
<span class="c1"># Add changes to git.</span>
git add .

<span class="c1"># Commit changes.</span>
<span class="nv">msg</span><span class="o">=</span><span class="s2">&#34;rebuilding site `date`&#34;</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">1</span> <span class="o">]</span>
  <span class="k">then</span> <span class="nv">msg</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span>
<span class="k">fi</span>
git commit -m <span class="s2">&#34;</span><span class="nv">$msg</span><span class="s2">&#34;</span>

<span class="c1"># Push source and build repos.</span>
git push origin main

<span class="c1"># Come Back up to the Project Root</span>
<span class="nb">cd</span> ..
</code></pre></div><p>把以上命令保存为 .sh 文件，然后再运行以下命令,修改 <code>deploy.sh</code> 的权限</p>
<pre><code>chmod +x deploy.sh
</code></pre><p>运行以下命令完成 <code>push</code> 整个博客的操作</p>
<pre><code>./deploy.sh &quot;Your optional commit message&quot;
</code></pre><p>然后把 <code>myblog</code> 里的内容同步到 GitHub 上。同时要在 <code>data</code>、<code>layouts</code>、<code>static</code> 里面添加一个 <code>.gitkeep</code> 文件，以保持目录结构。记住一定要删掉你的主题目录里面的 <code>.git</code> 文件夹</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git remote add origin git@github.com:github_user_name/your_repository.git    <span class="c1">#  your_repository 即你存放你的博客源文件的仓库</span>
git pull origin main
git add .
git commit -m <span class="s2">&#34;the message you want to write&#34;</span>
git push -u origin main    <span class="c1"># 第二次 push 可以不用加 -u</span>
</code></pre></div><p>到这里就大功告成了，如果你要在另一台电脑上继续写博客，只要把 <code>myhugo</code>克隆下来，然后把里面“看得见”的东西拷贝到一个新的文件夹(即除了 <code>.git</code> 、<code>.gitmodule</code> 等)，然后再重复刚才创建 git 子模块的那些步骤，当然你要准备 Hugo 环境。如果你想获取你的主题的最新更新，则在你的主题根目录下运行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git init
git remote add origin https://github.com/author_name/your_theme_repo_name.git
git pull    <span class="c1"># or git pull origin main</span>
</code></pre></div><h2 id="3-参考资料">3. 参考资料</h2>
<p><a href="https://fengberlin.github.io/post/use-hugo-to-build-blog/">使用Hugo搭建个人博客</a>，by Berlin</p>
<p><a href="https://gohugo.io/">HUGO官网</a></p>
]]></content>
		</item>
		
	</channel>
</rss>
